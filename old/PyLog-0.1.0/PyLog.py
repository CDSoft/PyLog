#!/usr/bin/env python


#........[ TOY PARSER GENERATOR  v 0.1.5 ]................!
#                                                        ! !
# Warning: This file was automatically generated by TPG ! | !
# Do not edit this file unless you know what you do.   !  |  !
#                                                     !   @   !
#....................................................!!!!!!!!!!!
#
# For further information about TPG you can visit
# http://christophe.delord.free.fr/tpg

from __future__ import generators
import pre
class Node(list):
	""" Base class for AST nodes

	An AST is a list. It can be seen as a term: the class name is the functor
	and the items are the arguments.

	Reserved method names :
		init : __init__ customisation
	Reserved attribute names :
		line : line of the current token in the input stream
		env  : pointer to the parser object containing global variables (global for nodes)
	"""
	def __init__(self, line, env, *args):
		""" Initialises the node and calls init with args """
		list.__init__(self)
		self.line = line
		self.env = env
		self += args
		apply(self.init,args)
	def init(self, *args):
		""" Default initialiser """
		pass
	def __str__(self):
		""" Prints the term """
		return "%s(%s)"%(self.__class__.__name__,','.join(map(str,self)))
class ToyParser:
	""" Base class for all Toy Parsers

	Reserved method and attribute names :
		init
		setInput
		line
		error
		check
		Parse
		tgp_*
	Reserved local variable names (in methods) :
		tpg_*
	"""

	class tpg_Error:
		""" Syntax error exception """
		def __init__(self, line):
			self.line = line
		def __str__(self):
			return '%d: Syntax error'%self.line

	class tpg_Pos:
		""" Position mark. Used to store the current position of the parser """
		def __init__(self, pos=0, line=1):
			self.pos = pos
			self.line = line

	def __init__(self, *args):
		""" Initialises the parser and calls the (redefined) initialiser """
		self.tpg_regexps = {}
		apply(self.init,args)

	def init(self):
		""" Default initialiser """
		pass

	def setInput(self, input):
		""" Stores the string to be parsed """
		self.tpg_input = input
		self.line= 0

	def error(self, p):
		""" Raises a syntax error """
		raise self.tpg_Error(p.line)

	def tpg_eat(self, p0, regexp, split=0):
		""" Lexical scanner for syntactic rules: skip* lex_eat """
		p1, = self.tpg_lex_skip(p0)
		return self.tpg_lex_eat(p1, regexp, split)

	def tpg_lex_skip(self, p0):
		""" Lexical scanner for separators: skip* """
		try:
			skip = self.skip		# Retrieve the skip symbol if any
		except AttributeError:
			return p0,				# if none, stop scanning
		while 1:
			try:
				p1, = skip(p0)		# Scan skip symbol as many times as possible
				p0 = p1
			except self.tpg_Error:
				p1 = p0
				break
		return p1,

	def tpg_lex_eat(self, p0, regexp, split=0):
		""" Lexical scanner for lexical rules. Tries to parse a given regular expression. """
		try:
			r = self.tpg_regexps[regexp]	# Retrieve the corresponding regexp
		except KeyError:
			r = pre.compile(regexp)			# or make it if necessary
			self.tpg_regexps[regexp] = r
		token = r.match(self.tpg_input, p0.pos)		# match the input ?
		if token:
			self.line = p0.line+self.tpg_input.count('\n', p0.pos, token.end())
			p1 = self.tpg_Pos(token.end(), self.line)	# store new position
			if split == 0: return p1,					# and return nothing ('re')
			if split == 1: return p1, token.group()		# or the whole text ('re'/x)
			if split == 2: return p1, token.groups()	# or all items ('re'/<x,y,z>)
		return self.error(p0)				# bad token => raise error to backtrack

	def check(self, cond):
		""" Check a condition and raise an parse error if false """
		if not cond: raise self.tpg_Error(self.line)

	def Parse(self, symbol, input, *args):
		""" Parse the string input starting from symbol """
		self.setInput(input)
		return apply(getattr(self,symbol), [self.tpg_Pos()]+list(args))[1]


#####################################################################
#                                                                   #
# PyLog: First order logic and PROLOG in Python                     #
#                                                                   #
# For further information about PyLog, please visit                 #
# http://christophe.delord.free.fr                                  #
# or contact the author at                                          #
# mailto:christophe.delord@free.fr                                  #
#                                                                   #
# Have fun with PyLog                                               #
#                                                                   #
# Christophe Delord.                                                #
#                                                                   #
#####################################################################

__date__ = "27 january 2002"
__version__ = "0.1.0"
__author__ = "Christophe Delord <christophe.delord@free.fr>"

#####################################################################
#                                                                   #
# Basic PyLog object                                                #
#                                                                   #
#####################################################################

class PyLogObject: pass

#####################################################################
#                                                                   #
# Atoms                                                             #
#                                                                   #
#####################################################################

class Atom(PyLogObject):

	def __init__(self, object):
		self.object = object

	def __str__(self):
		return str(self.object)

	def __repr__(self):
		return "Atom(%s)"%repr(self.object)

	def __call__(self):
		return self

#####################################################################
#                                                                   #
# Terms                                                             #
#                                                                   #
#####################################################################

def _mkPyLogObject(object):
	if isinstance(object, PyLogObject):
		return object
	else:
		return Atom(object)

def _str(t,l=10):
	if l==0: return "..."
	t = t()
	if isinstance(t, Atom):
		return str(t.object)
	elif isinstance(t, Term):
		return "%s(%s)"%(t.__class__.__name__,",".join(map(_str,t.args,[l-1]*t.arity)))
	elif isinstance(t, Var):
		return t.name
	return "???"

class Term(PyLogObject):

	def __init__(self, *args):
		self.args = map(_mkPyLogObject,args)
		self.arity = len(args)

	def arg(self, i):
		return self.args[i]

	def __str__(self):
		return _str(self)

	def __repr__(self):
		return _str(self)
	
	def __call__(self):
		return self

#####################################################################
#                                                                   #
# Lists                                                             #
#                                                                   #
#####################################################################

class Lst(Term):

	def __init__(self, head, tail):
		Term.__init__(self, head, tail)
		self.head, self.tail = self.args

	def __str__(self):
		return _strlist(self)

def _strlist(lst):
	l = []
	h, t = lst.head(), lst.tail()
	while 1:
		l.append(str(h))
		#print repr(t)
		if not isinstance(t,Lst):
			break
		else:
			h, t = t.head(), t.tail()
	head = ','.join(l)
	if isinstance(t, Nil):
		tail = ''
	else:
		tail = '|%s'%str(t)
	return '[%s%s]'%(head,tail)

class Nil(Term):

	def __init__(self):
		Term.__init__(self)

	def __str__(self):
		return "[]"

#####################################################################
#                                                                   #
# Variables                                                         #
#                                                                   #
#####################################################################

class BoundingError(Exception): pass 

class Var(PyLogObject):

	_count = {}

	def __init__(self, name="_"):
		self.term = None
		try:
			self.name = "%s%d"%(name, self.__class__._count[name])
			self.__class__._count[name] += 1
		except KeyError:
			self.name = name
			self.__class__._count[name] = 1

	def __str__(self):
		var = self()
		if isinstance(var, Var):
			return var.name
		else:
			return str(var)

	def __repr__(self):
		return "Var(%s)"%self.name

	def __call__(self):
		if self.term is not None:
			return self.term()
		else:
			return self

	def bound(self, object):
		var = self()
		term = _mkPyLogObject(object)
		if isinstance(var, Var):
			var.term = term
		else:
			raise BoundingError, "Cannot bound non free variables"

#####################################################################
#                                                                   #
# Most General Unifier                                              #
#                                                                   #
#####################################################################

# A unifier is an associative array {var}->{object}

class Unifier(dict):
	def __str__(self):
		return " ".join([ "%s/%s"%(t,v.name) for v,t in self.items() ])
	def unify(self):
		self.backup = {}
		for v, t in self.items():
			self.backup[v] = v.term
			v.bound(t)
	def undo(self):
		for v, t in self.backup.items():
			v.term = t

def mgu(t1, t2):
	u = Unifier()				# unifieur courant
	stack = [(t1(),t2())]		# pile des objets à unifier
	done = []					# objets déjà unifiés
	class NoMGU(Exception): pass
	def store(t1, t2):
		t1, t2 = t1(), t2()
		if (t1, t2) not in stack and (t1, t2) not in done:
			stack.append((t1, t2))
	def update(v, t):
		try:
			store(u[v], t)
		except KeyError:
			u[v] = t
	def atom_atom(a1, a2):
		if a1.object != a2.object: raise NoMGU
	def term_atom(t, a):
		raise NoMGU
	def term_term(t1, t2):
		if t1.__class__ == t2.__class__ and t1.arity == t2.arity:
			for (a1, a2) in map(None, t1.args, t2.args):
				store(a1, a2)
		else:
			raise NoMGU
	def var_atom(v, a):
		update(v, a)
	def var_term(v, t):
		update(v, t)
	def var_var(v1, v2):
		update(v1, v2)
	try:
		while stack:
			(t1, t2) = stack.pop()
			done.append((t1, t2))
			if isinstance(t1, Atom):
				if isinstance(t2, Atom): atom_atom(t1,t2)
				elif isinstance(t2, Term): term_atom(t2,t1)
				elif isinstance(t2, Var): var_atom(t2,t1)
				else: type_error()
			elif isinstance(t1, Term):
				if isinstance(t2, Atom): term_atom(t1,t2)
				elif isinstance(t2, Term): term_term(t1,t2)
				elif isinstance(t2, Var): var_term(t2,t1)
				else: type_error()
			elif isinstance(t1, Var):
				if isinstance(t2, Atom): var_atom(t1,t2)
				elif isinstance(t2, Term): var_term(t1,t2)
				elif isinstance(t2, Var): var_var(t1,t2)
				else: type_error()
	except NoMGU:
		return None
	return u

#####################################################################
#                                                                   #
# Unification                                                       #
#                                                                   #
#####################################################################

def unify(t1, t2):
	u = mgu(t1, t2)
	if u:
		u.unify()
		return u
	raise UnificationError



#####################################################################
#                                                                   #
# PROLOG engine                                                     #
#                                                                   #
#####################################################################

class PyLogEngine:

	class Cut(Exception):
		""" Raised by '!' in Prolog rules """
		pass

	def Goal(self, name, args):
		for _ in apply(name, args):
			yield 1

	def true(self):
		yield 1

	def fail(self):
		return
		yield None

	def And(self, *preds):
		if preds:
			(name, args), follow = preds[0], preds[1:]
			for _ in apply(name, args):
				for _ in apply(self.And, follow):
					yield 1
		else:
			yield 1

	def Or(self, *preds):
		try:
			for name, args in preds:
				for _ in apply(name, args):
					yield 1
		except self.Cut:
			return

	def cut(self):
		yield 1
		raise self.Cut

	def unify(self, X, Y):
		u=mgu(X,Y)
		if u is not None:
			u.unify()
			yield 1
			u.undo()



import string

def _flatten(L):
	for i in L:
		if type(i) == list:
			for j in _flatten(i):
				yield j
		else:
			yield i

def _if(cond, true, false):
	if cond:
		return true
	else:
		return false

_import_generators =	[
							"from __future__ import generators",
						]
_imports =				[
							"from PyLog import *",
						]

class _Prolog(Node):
	def genCode(self, indent=0):
		imports =	[	_if(self.env.import_generators,_import_generators,[]),
						_imports,
					]						
		return '\n'.join(list(_flatten([imports,[m.genCode(indent) for m in self],""])))

class _Module(Node):
	def init(self, name, imports):
		self.name, self.imports = name, imports
		self.rules = {}
		self.codes = []
	def genCode(self, indent):
		tab = "\t"*indent
		return	[	tab+"class %s(PyLogEngine, %s):"%(self.name, ', '.join(self.imports)),
					[ rule.genCode(indent+1) for rule in self.rules.values() ],
				]
	def append(self, rule):
		if isinstance(rule, _Code):
			self.codes.append(rule)
		else:
			try:
				self.env.check(self.rules[rule.name].add(rule))
			except KeyError:
				self.rules[rule.name] = _Predicate(rule)

def unindent(lines):
	""" Remove indentation in lines that is common to each line """
	def non_blank(l):
		for c in l:
			if c not in ' \t': return 1
	def tabs(l):
		t = 0
		for c in l:
			if c not in ' \t': break
			t += 1
		return t
	t = min([tabs(l) for l in lines if non_blank(l)])
	return [line[t:] for line in lines]

def reindent(indent, lines):
	""" Reindent all lines """
	tab = '\t'*indent
	return	[tab + line for line in lines] 

class _Code(Node):
	def init(self, code):
		self.code = unindent(code.splitlines())
	def genCode(self, indent):
		return reindent(indent, self.code)

class _Predicate:
	def __init__(self, rule):
		self.name = rule.name
		self.rules = [rule]
		rule.predicate = self
		self.arity = len(rule.args)
		self.args = [ 'PyL_%d'%i for i in range(self.arity) ]
	def add(self, rule):
		if len(rule.args)!=self.arity: return None
		self.rules.append(rule)
		rule.predicate = self
		return 1
	def genCode(self, indent):
		tab = "\t"*indent
		return	[	tab+ "def %s(self, %s):"%(self.name, ','.join(self.args)),
					[ rule.genCode(indent+1) for rule in self.rules ],
				]

class _Imports(Node):
	pass 

class _Args(Node):
	def getVars(self, variables):
		for arg in self: arg.getVars(variables)

class _True(Node):
	def getVars(self, variables):
		pass
	def genCode(self):
		return "self.true()"
	def genPCode(self):
		return "(self.true,[])"

class _Rule(Node):
	def init(self, name, args, expr):
		self.name, self.args, self.expr = name, args, expr
	def genCode(self, indent):
		tab = "\t"*indent
		variables = []
		for arg in self.args: arg.getVars(variables)
		self.expr.getVars(variables)
		arguments = self.predicate.arity>0
		return	[	tab+	"try:",
					_if(variables,tab+"\t%s = %s"%(','.join(variables), ','.join(["Var()"]*len(variables))),[]),
					_if(arguments,tab+"\tu=mgu(Term(%s),Term(%s))"%(','.join(self.predicate.args), ','.join([ term.genCode() for term in self.args ])),[]),
					_if(arguments,tab+"\tif u is not None:",[]),
					_if(arguments,tab+"\t\tu.unify()",[]),
					tab+	"\t\tfor _ in self.Goal%s:"%self.expr.genPCode(),
					tab+	"\t\t\tyield 1",
					_if(arguments,tab+"\t\tu.undo()",[]),
					tab+	"except self.Cut:",
					tab+	"\treturn",
				]

class _Var(Node):
	def init(self, name):
		self.name = name
	def getVars(self, variables):
		if self.name is not None and self.name not in variables:
			variables.append(self.name)
	def genCode(self):
		if self.name is None:
			return "Var()"
		else:
			return self.name

class _Atom(Node):
	def init(self, object):
		self.object = object
	def getVars(self, variables):
		pass
	def genCode(self):
		return repr(self.object)

class _List(Node):
	def init(self, head, tail):
		self.head, self.tail = head, tail
	def getVars(self, variables):
		self.head.getVars(variables)
		self.tail.getVars(variables)
	def genCode(self):
		return self.code(self.head,self.tail)
	def code(self, head, tail):
		if len(head)==1:
			return "Lst(%s,%s)"%(head[0].genCode(), tail.genCode())
		else:
			return "Lst(%s,%s)"%(head[0].genCode(), self.code(head[1:],tail))

class _Nil(Node):
	def getVars(self, variables):
		pass
	def genCode(self):
		return "Nil()"

class _HeadList(Node):
	def getVars(self, variables):
		for term in self:
			term.getVars(variables)

class _Term(Node):
	def init(self, name, args):
		self.name, self.args = name, args
	def getVars(self, variables):
		self.args.getVars(variables)
	def genCode(self):
		return "%s(%s)"%(self.name,','.join([arg.genCode() for arg in self.args]))

class _Pred(Node):
	def init(self, name, args):
		self.name, self.args = name, args
	def getVars(self, variables):
		self.args.getVars(variables)
	def genCode(self):
		return "self.%s(%s)"%(self.name,','.join([arg.genCode() for arg in self.args]))
	def genPCode(self):
		return "(self.%s,[%s])"%(self.name,','.join([arg.genCode() for arg in self.args]))

class _Or(Node):
	def getVars(self, variables):
		for t in self: t.getVars(variables)
	def genPCode(self):
		return "(self.Or,[%s])"%(','.join([t.genPCode() for t in self]))

class _And(Node):
	def getVars(self, variables):
		for t in self: t.getVars(variables)
	def genPCode(self):
		return "(self.And,[%s])"%(','.join([t.genPCode() for t in self]))

class _Cut(Node):
	def getVars(self, variables):
		pass
	def genPCode(self):
		return "(self.cut,[])"

class _Unify(Node):
	def init(self, x, y):
		self.x, self.y = x, y
	def getVars(self, variables):
		self.x.getVars(variables)
		self.y.getVars(variables)
	def genPCode(self):
		return "(self.unify,[%s,%s])"%(self.x.genCode(),self.y.genCode())

class PyLogParser(ToyParser, ):
	
	def init(self, import_generators=0):
		self.import_generators=import_generators
	def __call__(self, input, *args):
		""" Call the axiom of the grammar (the START symbol) """
		self.setInput(input)
		return apply(self.START, [self.tpg_Pos()]+list(args))[1]

	def START(self, tpg_p0, ):
		"""START -> ( 'main' ':' ( CODE )* | MODULE )* '$' ."""
		prog = _Prolog(self.line, self, )
		while 1:
			try:
				try:
					tpg_p4,  = self.tpg_eat(tpg_p0, r'main', 0)
					tpg_p5,  = self.tpg_eat(tpg_p4, r':', 0)
					while 1:
						try:
							tpg_p2, c = self.CODE(tpg_p5, )
							prog.append(c)
							tpg_p5 = tpg_p2
						except self.tpg_Error:
							tpg_p2 = tpg_p5
							break
				except self.tpg_Error:
					tpg_p2, m = self.MODULE(tpg_p0, )
					prog.append(m)
				tpg_p0 = tpg_p2
			except self.tpg_Error:
				tpg_p2 = tpg_p0
				break
		tpg_p1,  = self.tpg_eat(tpg_p2, r'$', 0)
		code = prog.genCode() 
		return tpg_p1, code
	def CODE(self, tpg_p0, ):
		"""CODE -> '{{((?:.|\n)*?)}}' ."""
		tpg_p1, (c,) = self.tpg_eat(tpg_p0, r'{{((?:.|\n)*?)}}', 2)
		return tpg_p1, _Code(self.line, self, c)
	def MODULE(self, tpg_p0, ):
		"""MODULE -> ident ( '\(' ident ( ',' ident )* '\)' )? ':' ( RULE | CODE )* ."""
		tpg_p2, name = self.ident(tpg_p0, )
		imports = _Imports(self.line, self, )
		try:
			tpg_p6,  = self.tpg_eat(tpg_p2, r'\(', 0)
			tpg_p7, i = self.ident(tpg_p6, )
			imports.append(i)
			while 1:
				try:
					tpg_p10,  = self.tpg_eat(tpg_p7, r',', 0)
					tpg_p8, i = self.ident(tpg_p10, )
					imports.append(i)
					tpg_p7 = tpg_p8
				except self.tpg_Error:
					tpg_p8 = tpg_p7
					break
			tpg_p3,  = self.tpg_eat(tpg_p8, r'\)', 0)
		except self.tpg_Error:
			tpg_p3 = tpg_p2
		tpg_p4,  = self.tpg_eat(tpg_p3, r':', 0)
		m = _Module(self.line, self, name, imports)
		while 1:
			try:
				try:
					tpg_p1, r = self.RULE(tpg_p4, )
					m.append(r)
				except self.tpg_Error:
					tpg_p1, c = self.CODE(tpg_p4, )
					m.append(c)
				tpg_p4 = tpg_p1
			except self.tpg_Error:
				tpg_p1 = tpg_p4
				break
		return tpg_p1, m
	def skip(self, tpg_p0, ):
		"""lex skip -> '\s+|#.*|%.*' ."""
		tpg_p1,  = self.tpg_lex_eat(tpg_p0, r'\s+|#.*|%.*', 0)
		return tpg_p1, 
	def RULE(self, tpg_p0, ):
		"""RULE -> IDENT ARGS ( ':-' EXPR |  ) '\.' ."""
		tpg_p2, name = self.IDENT(tpg_p0, )
		tpg_p3, args = self.ARGS(tpg_p2, )
		try:
			tpg_p6,  = self.tpg_eat(tpg_p3, r':-', 0)
			tpg_p4, expr = self.EXPR(tpg_p6, )
		except self.tpg_Error:
			expr = _True(self.line, self, )
			tpg_p4 = tpg_p3
		tpg_p1,  = self.tpg_eat(tpg_p4, r'\.', 0)
		return tpg_p1, _Rule(self.line, self, name, args, expr)
	def IDENT(self, tpg_p0, ):
		"""IDENT -> '[a-z]\w*' ."""
		tpg_p1, name = self.tpg_eat(tpg_p0, r'[a-z]\w*', 1)
		return tpg_p1, name
	def VARIDENT(self, tpg_p0, ):
		"""VARIDENT -> '[A-Z]\w*' ."""
		tpg_p1, name = self.tpg_eat(tpg_p0, r'[A-Z]\w*', 1)
		return tpg_p1, name
	def ident(self, tpg_p0, ):
		"""ident -> '[a-zA-Z]\w*' ."""
		tpg_p1, name = self.tpg_eat(tpg_p0, r'[a-zA-Z]\w*', 1)
		return tpg_p1, name
	def ARGS(self, tpg_p0, ):
		"""ARGS -> ( '\(' TERM ( ',' TERM )* '\)' )? ."""
		args = _Args(self.line, self, )
		try:
			tpg_p3,  = self.tpg_eat(tpg_p0, r'\(', 0)
			tpg_p4, a = self.TERM(tpg_p3, )
			args.append(a)
			while 1:
				try:
					tpg_p7,  = self.tpg_eat(tpg_p4, r',', 0)
					tpg_p5, a = self.TERM(tpg_p7, )
					args.append(a)
					tpg_p4 = tpg_p5
				except self.tpg_Error:
					tpg_p5 = tpg_p4
					break
			tpg_p1,  = self.tpg_eat(tpg_p5, r'\)', 0)
		except self.tpg_Error:
			tpg_p1 = tpg_p0
		return tpg_p1, args
	def EXPR(self, tpg_p0, ):
		"""EXPR -> or_EXPR ."""
		tpg_p1, e = self.or_EXPR(tpg_p0, )
		return tpg_p1, e
	def or_EXPR(self, tpg_p0, ):
		"""or_EXPR -> and_EXPR ( ';|\|' and_EXPR ( ';|\|' and_EXPR )* )? ."""
		tpg_p2, e = self.and_EXPR(tpg_p0, )
		try:
			tpg_p4,  = self.tpg_eat(tpg_p2, r';|\|', 0)
			tpg_p5, a = self.and_EXPR(tpg_p4, )
			e = _Or(self.line, self, e, a)
			while 1:
				try:
					tpg_p7,  = self.tpg_eat(tpg_p5, r';|\|', 0)
					tpg_p1, a = self.and_EXPR(tpg_p7, )
					e.append(a)
					tpg_p5 = tpg_p1
				except self.tpg_Error:
					tpg_p1 = tpg_p5
					break
		except self.tpg_Error:
			tpg_p1 = tpg_p2
		return tpg_p1, e
	def and_EXPR(self, tpg_p0, ):
		"""and_EXPR -> atom_EXPR ( ',' atom_EXPR ( ',' atom_EXPR )* )? ."""
		tpg_p2, e = self.atom_EXPR(tpg_p0, )
		try:
			tpg_p4,  = self.tpg_eat(tpg_p2, r',', 0)
			tpg_p5, a = self.atom_EXPR(tpg_p4, )
			e = _And(self.line, self, e, a)
			while 1:
				try:
					tpg_p7,  = self.tpg_eat(tpg_p5, r',', 0)
					tpg_p1, a = self.atom_EXPR(tpg_p7, )
					e.append(a)
					tpg_p5 = tpg_p1
				except self.tpg_Error:
					tpg_p1 = tpg_p5
					break
		except self.tpg_Error:
			tpg_p1 = tpg_p2
		return tpg_p1, e
	def atom_EXPR(self, tpg_p0, ):
		"""atom_EXPR -> PREDICATE | '\(' EXPR '\)' ."""
		try:
			tpg_p1, a = self.PREDICATE(tpg_p0, )
		except self.tpg_Error:
			tpg_p3,  = self.tpg_eat(tpg_p0, r'\(', 0)
			tpg_p4, a = self.EXPR(tpg_p3, )
			tpg_p1,  = self.tpg_eat(tpg_p4, r'\)', 0)
		return tpg_p1, a
	def PREDICATE(self, tpg_p0, ):
		"""PREDICATE -> '\!' | TERM '=' TERM | IDENT ARGS ."""
		try:
			try:
				tpg_p1,  = self.tpg_eat(tpg_p0, r'\!', 0)
				p = _Cut(self.line, self, )
			except self.tpg_Error:
				tpg_p3, a = self.TERM(tpg_p0, )
				tpg_p4,  = self.tpg_eat(tpg_p3, r'=', 0)
				tpg_p1, b = self.TERM(tpg_p4, )
				p = _Unify(self.line, self, a, b)
		except self.tpg_Error:
			tpg_p6, name = self.IDENT(tpg_p0, )
			tpg_p1, args = self.ARGS(tpg_p6, )
			p = _Pred(self.line, self, name, args)
		return tpg_p1, p
	def TERM(self, tpg_p0, ):
		"""TERM -> IDENT ARGS | VARIDENT | '_' | STRING | NUMBER | LIST ."""
		try:
			try:
				try:
					try:
						try:
							tpg_p2, name = self.IDENT(tpg_p0, )
							tpg_p1, args = self.ARGS(tpg_p2, )
							t = _Term(self.line, self, name, args)
						except self.tpg_Error:
							tpg_p1, name = self.VARIDENT(tpg_p0, )
							t = _Var(self.line, self, name)
					except self.tpg_Error:
						tpg_p1,  = self.tpg_eat(tpg_p0, r'_', 0)
						t = _Var(self.line, self, None)
				except self.tpg_Error:
					tpg_p1, st = self.STRING(tpg_p0, )
					t = _Atom(self.line, self, st)
			except self.tpg_Error:
				tpg_p1, n = self.NUMBER(tpg_p0, )
				t = _Atom(self.line, self, n)
		except self.tpg_Error:
			tpg_p1, t = self.LIST(tpg_p0, )
		return tpg_p1, t
	def STRING(self, tpg_p0, ):
		"""STRING -> '\'([^\']*)\'' | '"([^"]*)"' ."""
		try:
			tpg_p1, (st,) = self.tpg_eat(tpg_p0, r'\'([^\']*)\'', 2)
		except self.tpg_Error:
			tpg_p1, (st,) = self.tpg_eat(tpg_p0, r'"([^"]*)"', 2)
		return tpg_p1, st
	def NUMBER(self, tpg_p0, ):
		"""NUMBER -> '\d+\.\d*|\.\d+' | '\d+' ."""
		try:
			tpg_p1, st = self.tpg_eat(tpg_p0, r'\d+\.\d*|\.\d+', 1)
			n=self.atof(st) 
		except self.tpg_Error:
			tpg_p1, st = self.tpg_eat(tpg_p0, r'\d+', 1)
			n=self.atoi(st) 
		return tpg_p1, n
	
	def atof(self, st):
		return string.atof(st)
	def atoi(self, st):
		try:
			return string.atoi(st)
		except ValueError:
			return string.atol(st)
	
	def LIST(self, tpg_p0, ):
		"""LIST -> '\[' head_LIST ( '\|' tail_LIST |  ) '\]' | '\[' '\]' ."""
		try:
			tpg_p2,  = self.tpg_eat(tpg_p0, r'\[', 0)
			tpg_p3, h = self.head_LIST(tpg_p2, )
			try:
				tpg_p6,  = self.tpg_eat(tpg_p3, r'\|', 0)
				tpg_p4, t = self.tail_LIST(tpg_p6, )
			except self.tpg_Error:
				t = _Nil(self.line, self, )
				tpg_p4 = tpg_p3
			tpg_p1,  = self.tpg_eat(tpg_p4, r'\]', 0)
			l = _List(self.line, self, h, t)
		except self.tpg_Error:
			tpg_p8,  = self.tpg_eat(tpg_p0, r'\[', 0)
			tpg_p1,  = self.tpg_eat(tpg_p8, r'\]', 0)
			l = _Nil(self.line, self, )
		return tpg_p1, l
	def head_LIST(self, tpg_p0, ):
		"""head_LIST -> TERM ( ',' TERM )* ."""
		h = _HeadList(self.line, self, )
		tpg_p2, a = self.TERM(tpg_p0, )
		h.append(a)
		while 1:
			try:
				tpg_p4,  = self.tpg_eat(tpg_p2, r',', 0)
				tpg_p1, a = self.TERM(tpg_p4, )
				h.append(a)
				tpg_p2 = tpg_p1
			except self.tpg_Error:
				tpg_p1 = tpg_p2
				break
		return tpg_p1, h
	def tail_LIST(self, tpg_p0, ):
		"""tail_LIST -> TERM ."""
		tpg_p1, t = self.TERM(tpg_p0, )
		return tpg_p1, t
class ArgParser(ToyParser, ):
	def skip(self, tpg_p0, ):
		"""lex skip -> '\s+' ."""
		tpg_p1,  = self.tpg_lex_eat(tpg_p0, r'\s+', 0)
		return tpg_p1, 
	def __call__(self, input, *args):
		""" Call the axiom of the grammar (the START symbol) """
		self.setInput(input)
		return apply(self.START, [self.tpg_Pos()]+list(args))[1]

	def START(self, tpg_p0, ):
		"""START -> ( '([^\s]|\\\s)+\.pro' | '-o' '([^\s]|\\\s)+\.py' )* '$' ."""
		input_file, output_file = None, None 
		while 1:
			try:
				try:
					tpg_p2, st = self.tpg_eat(tpg_p0, r'([^\s]|\\\s)+\.pro', 1)
					
					self.check(input_file is None)
					input_file = st
					
				except self.tpg_Error:
					tpg_p5,  = self.tpg_eat(tpg_p0, r'-o', 0)
					tpg_p2, st = self.tpg_eat(tpg_p5, r'([^\s]|\\\s)+\.py', 1)
					
					self.check(output_file is None)
					output_file = st
					
				tpg_p0 = tpg_p2
			except self.tpg_Error:
				tpg_p2 = tpg_p0
				break
		
		self.check(input_file is not None)
		if output_file is None: output_file = input_file[:-4]+'.py'
		
		tpg_p1,  = self.tpg_eat(tpg_p2, r'$', 0)
		return tpg_p1, (input_file, output_file,)


if __name__ == "__main__":

	import sys

	print "PyLog v%s (c) Christophe Delord"%__version__
	try:
		argParser = ArgParser()
		(prolog_file, output_file) = argParser(' '.join(sys.argv[1:]))
	except ArgParser.tpg_Error:
		sys.stderr.write("Syntax: %s prolog_file.pro [-o output_file.py]\n"%sys.argv[0])
	else:
		print "PyLog: translating %s to %s"%(prolog_file, output_file)
		f = open(prolog_file, 'r')
		g = open(output_file, 'w')
		g.write(PyLogParser(1)(f.read()))
		f.close()
		g.close()
		print "Translation OK"

